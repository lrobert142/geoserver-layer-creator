/*
@author	Stuart Garrigan
@version 1.0.1
@since 11/12/2014
 */

package au.gov.aims.utilities;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;
import au.com.bytecode.opencsv.bean.CsvToBean;
import au.com.bytecode.opencsv.bean.HeaderColumnNameTranslateMappingStrategy;
import au.gov.aims.interfaces.GeoServerFileCsvParserInterface;
import au.gov.aims.model.GeoServerFile;

/**
 * Handles the writing and parsing of shape files to and from .csv.
 *
 */

public class GeoServerFileCsvParser implements GeoServerFileCsvParserInterface {
	// Attributes
	public Logger logger;

	// Constructor
	public GeoServerFileCsvParser() {
		logger = Logger.getLogger(GeoServerFileCsvParser.class);
	}

	/**
	 * Access a .csv and parse each row into a java bean. Using
	 * HeadingColumnNameTranslateMappingStrategy.
	 *
	 * @param The
	 *            absolute path of the desired shapeFile .csv to parse.
	 * @return Returns a a list of files parsed to a java bean.
	 */
	@Override
	public List<GeoServerFile> parseGeoServerFileToJavaBean(String fileNameToParse) throws IOException {
		HeaderColumnNameTranslateMappingStrategy<GeoServerFile> beanStrategy = new HeaderColumnNameTranslateMappingStrategy<GeoServerFile>();
		beanStrategy.setType(GeoServerFile.class);

		Map<String, String> columnMapping = new HashMap<String, String>();
		columnMapping.put("storePath", "storePath");
		columnMapping.put("storeName", "storeName");
		columnMapping.put("layerName", "layerName");
		columnMapping.put("workspace", "workspace");
		columnMapping.put("storeType", "storeType");
		columnMapping.put("title", "title");
		columnMapping.put("abstract", "layerAbstract");
		columnMapping.put("metadataXmlHref", "metadataXmlHref");
		columnMapping.put("keywords", "keywords");
		columnMapping.put("wmsPath", "wmsPath");
		columnMapping.put("styles", "styles");
		columnMapping.put("uploadData", "uploadData");
		columnMapping.put("uploadMetadata", "uploadMetadata");

		beanStrategy.setColumnMapping(columnMapping);

		CsvToBean<GeoServerFile> csvToBean = new CsvToBean<GeoServerFile>();
		CSVReader reader = new CSVReader(new FileReader(fileNameToParse), ',');

		List<GeoServerFile> shapeFiles = csvToBean.parse(beanStrategy, reader);
		
		//Looks to remove example columns from the bean list no matter where they have ended up.
		for (int i = 0; i < shapeFiles.size(); i++) {
			if(shapeFiles.get(i).getStorePath().contains("EXAMPLE_ONLY")){
				shapeFiles.remove(i);
			}
			if(shapeFiles.get(i).getStorePath().contains("DESCRIPTION_ONLY")){
				shapeFiles.remove(i);
			}
		}
				
		reader.close();
		return shapeFiles;
	}

	/**
	 * Write a list of files to a specified .csv. Takes a list of files which
	 * are converted to a List of String Arrays before being written the .csv.
	 *
	 * @param The
	 *            list of files to be written to a .csv
	 * @param The
	 *            absolute path of the desired output location of the written
	 *            .csv.
	 */
	@Override
	public void writeFilesToCsv(List<File> files, String targetFileName) {
		try {
			FileWriter fileWriter = new FileWriter(targetFileName);
			CSVWriter csvWriter = new CSVWriter(fileWriter, ',');
			
			List<String[]> data = toStringArray(files, getRelativePath(targetFileName));
			csvWriter.writeAll(data);

			csvWriter.close();
			fileWriter.close();
		} catch (Exception e) {
			logger.debug(e.getStackTrace() + "An error has occured when writing to a .csv");
		}
	}
	
	/**
	 * Converts absolute file paths containing '\' characters and converts them to '/' characters
	 * @param Absoulte path for a file to be converted.
	 * @return The converted string.
	 */
	public String backslashToForwardslash(String path) {
		StringBuilder builder = new StringBuilder();
		char[] pathArray = path.toCharArray();
		
		for (int j = 0; j < pathArray.length; j++) {
			if(pathArray[j] == '\\')
				pathArray[j] = '/';
			builder.append(pathArray[j]);
		}
		return builder.toString();
	}
	
	/**
	 * Convert a list of File objects to a List of String Arrays.
	 *
	 * @param The
	 *            list of files to be written to be converted.
	 * 
	 * @return a List of String Arrays.
	 */
	public List<String[]> toStringArray(List<File> fileList, String homeDirectory) {
		List<String[]> records = new ArrayList<String[]>();
		// add header record to the csv.
		records.add(new String[] { "storePath", "storeName",
				"layerName", "workspace", "storeType", "title", "abstract",
				"metadataXmlHref", "keywords", "wmsPath", "styles",
				"uploadData", "uploadMetadata" });
		
		// Add 2 rows for example and description information. When parsed the program 
		// will look for the flags "EXAMPLE_ONLY" and "DESCRIPTION_ONLY"
		// these rows will be ignored when the csv is parsed to a bean.
		records.add(new String[]{"EXAMPLE_ONLY", "This will be an example"});
		records.add(new String[]{"DESCRIPTION_ONLY", "This is another example"});


		// Add new record per object in list with defaults entries to the csv.
		Iterator<File> it = fileList.iterator();
		while (it.hasNext()) {
			try {
				File file = it.next();
				
//				String relativePath = RelativePathConverter.convertToRelativePath(file.getAbsolutePath(), file.getParent()) + "/" + file.getName();
				String relativePath = absoluteToRelativePath(file.getAbsolutePath(), homeDirectory);
				String shortName = file.getName().substring(0, file.getName().length() - 4);
				
				if(file.toString().endsWith(".shp")){
				records.add(new String[] {relativePath,
						shortName, shortName, "", "Shapefile", "", "", "something.xml",
						"e.g. Maritime Boundary", relativePath, "", "TRUE", "TRUE" });
				}
				
				else if(file.toString().endsWith(".tif")){
					records.add(new String[] {relativePath,
							shortName, shortName, "", "GeoTiff", "", "", "something.xml",
							"e.g. Maritime Boundary", relativePath, "", "TRUE", "TRUE" });
					}
			} catch (IndexOutOfBoundsException e) {
				logger.debug(e.getStackTrace() + "An error occured when writing object to .csv, likely caused by too many defaults or not enough to match number of columns");
			} catch (Exception e) {
				logger.debug(e.getStackTrace() + "Some other error has occured whilst trying to write an object to a .csv");
			}
		}
		return records;
	}
	
	private String absoluteToRelativePath(String absolutePath, String relativeDirectory) {
//		System.out.println(relativeDirectory);
//		System.out.println(absolutePath.substring(relativeDirectory.length(), absolutePath.length()));
		return "";
	}
	
	private String getRelativePath(String targetPath) {
		System.out.println(targetPath.substring(0, targetPath.lastIndexOf("\\")));
		return targetPath.substring(0, targetPath.lastIndexOf("\\"));
	}
}